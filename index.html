<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"upaskun.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="upa4的窝">
<meta property="og:url" content="https://upaskun.github.io/index.html">
<meta property="og:site_name" content="upa4的窝">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="upas">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://upaskun.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>upa4的窝</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">upa4的窝</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">🐟</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://upaskun.github.io/2024/02/01/CVE-2024-21626/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="upas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="upa4的窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/01/CVE-2024-21626/" class="post-title-link" itemprop="url">CVE-2024-21626</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-01 20:14:11" itemprop="dateCreated datePublished" datetime="2024-02-01T20:14:11+08:00">2024-02-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-18 08:52:54" itemprop="dateModified" datetime="2024-02-18T08:52:54+08:00">2024-02-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>TAT漏洞披露才几个钟头啊，佬怎么poc都写好了…</p>
<p>根据runc的描述, 漏洞成因是内部文件描述符泄漏。从runc v1.0.0-rc93开始，host上的<code>/sys/fs/cgroup</code> 就能在容器中看到了</p>
<p>PoC非常简单，只需要将容器的WORKDIR设置为<code>/proc/self/fd/&lt;num&gt;</code>(<code>num</code>在不同的内核上可能会不同，大致在4~10的范围内)就会可以泄露host的fs。</p>
<h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><h2 id="调用链分析"><a href="#调用链分析" class="headerlink" title="调用链分析"></a>调用链分析</h2><p>runc是如何处理用户设置的workdir的？为什么把<code>/proc/self/fd/xxx</code>的值设置为workdir就会出问题呢？<code>/proc/self/fd/xxx</code>和<code>/sys/fs/cgroup</code>又有什么关系呢?</p>
<p><code>libcontainer/cgroups/file.go:prepareOpenat2</code></p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>有一件非常奇怪的事情，poc只能在kernel版本&gt;&#x3D;5.4,&gt;&#x3D;4.19时才能触发，不是runc泄露了fd吗？和kernel版本有什么关系呢？</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://github.com/opencontainers/runc/security/advisories/GHSA-xr7r-f8xq-vfvv">https://github.com/opencontainers/runc/security/advisories/GHSA-xr7r-f8xq-vfvv</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/snyk/leaky-vessels-static-detector">https://github.com/snyk/leaky-vessels-static-detector</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/snyk/leaky-vessels-dynamic-detector">https://github.com/snyk/leaky-vessels-dynamic-detector</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/ssst0n3/c-listener(%E8%86%9C%E6%8B%9C%E5%B7%A8%E4%BD%AC!!)">https://github.com/ssst0n3/c-listener(膜拜巨佬!!)</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://upaskun.github.io/2024/01/31/apue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="upas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="upa4的窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/31/apue/" class="post-title-link" itemprop="url">apue</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-31 09:51:30 / 修改时间：12:52:34" itemprop="dateCreated datePublished" datetime="2024-01-31T09:51:30+08:00">2024-01-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/reading-notes/" itemprop="url" rel="index"><span itemprop="name">reading_notes</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p><code>fork()</code>函数被调用一次，返回两次，其中，子进程返回的值是<code>0</code>, 父进程返回的值是子进程的<code>id</code>。<br>子进程得到的是父进程数据空间、堆和栈的副本，子进程中对数据的更改不会影响到父进程。</p>
<p>父进程和子进程共享同一个被打开文件的偏移量和文件表项。</p>
<p><code>fork</code>的两种使用场景</p>
<ol>
<li>执行不同的代码段</li>
<li>执行不同的程序</li>
</ol>
<p>如果父进程先于子进程结束，子进程的父进程会变为<code>init</code>进程;<br>如果子进程先结束，父进程可以通过<code>wait</code>或<code>waitpid</code>函数获取子进程的终止状态</p>
<h3 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h3><h3 id="concurrent-programming"><a href="#concurrent-programming" class="headerlink" title="concurrent programming"></a>concurrent programming</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://upaskun.github.io/2024/01/23/pwn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="upas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="upa4的窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/23/pwn/" class="post-title-link" itemprop="url">pwn</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-23 17:11:14 / 修改时间：23:34:14" itemprop="dateCreated datePublished" datetime="2024-01-23T17:11:14+08:00">2024-01-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="堆利用"><a href="#堆利用" class="headerlink" title="堆利用"></a>堆利用</h2><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p>每个线程都会对应一个堆的内存分配区：Aerna</p>
<p>chunk: 一块内存区域</p>
<p>Bin: 本质是一个数组，用来管理暂时没有使用的chunk</p>
<p>bin管理的chunk可以分为四类</p>
<ol>
<li>fast bin chunk</li>
<li>small bin chunk: bins[2]~bins[63]</li>
<li>unsorted bin chunk: bins[1]</li>
<li>large bin chunk: bins[64]~bins[126]</li>
</ol>
<p><img src="/chunk.drawio.png" alt="Alt text"></p>
<p>bins是一个数组，small, unsorted, large chunk bin的索引都存放在这个数组中<br>unsorted chunk bins用来存放暂时还没被分类的chunk, 除了fast chunk bin(单向，栈方式取用), 其余的chunk都是双向链表，取用时遵循队列</p>
<p><em>使用malloc返回的是chunk的data字段的地址</em></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://upaskun.github.io/2024/01/19/todo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="upas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="upa4的窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/19/todo/" class="post-title-link" itemprop="url">todo</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-19 14:58:29" itemprop="dateCreated datePublished" datetime="2024-01-19T14:58:29+08:00">2024-01-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-22 18:42:01" itemprop="dateModified" datetime="2024-01-22T18:42:01+08:00">2024-01-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Current-Thoughts"><a href="#Current-Thoughts" class="headerlink" title="Current Thoughts"></a>Current Thoughts</h2><h3 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h3><ul>
<li><input disabled="" type="checkbox"> 插桩<ul>
<li><input disabled="" type="checkbox"> 插桩的粒度单位为函数<br>  比如： 检测到调用链FuncA call filepath.Join  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func FuncA(int a, int b)&#123;</span><br><span class="line">if I&gt;0&#123;</span><br><span class="line">	filepath.Join(a, b)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">	filepath.Join(b, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  以dockerd的接口为起点，遍历调用图中与mnt namespace相关的节点<br>  会在函数FuncA的所有filepath.Join函数后进行插桩</li>
<li><input disabled="" type="checkbox"> 插桩的内容<ol>
<li>与kernel通信，告知要检测的文件的名称</li>
<li>当前插桩点的位置信息</li>
</ol>
</li>
</ul>
</li>
<li><input disabled="" type="checkbox"> Fuzz<ul>
<li><input disabled="" type="checkbox"> 对每个命令的入口函数都编写相应的Fuzz函数(体力活)……这样就能准确的进行code coverage测试了</li>
</ul>
</li>
</ul>
<h3 id="容器内"><a href="#容器内" class="headerlink" title="容器内"></a>容器内</h3><ul>
<li><input disabled="" type="checkbox"> 同KIT一样，容器内执行syscall sequence，不过侧重点在mnt namespace；缺点：不一定能触发漏洞；没有创新点</li>
<li><input checked="" disabled="" type="checkbox"> 容器内执行PoC，缺点在于PoC样本空间太少</li>
<li>符号链接指向的文件，&#x2F;proc&#x2F;self&#x2F;fd等&#x2F;sys&#x2F;</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://upaskun.github.io/2024/01/04/sort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="upas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="upa4的窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/04/sort/" class="post-title-link" itemprop="url">sort</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-04 21:22:53 / 修改时间：21:24:39" itemprop="dateCreated datePublished" datetime="2024-01-04T21:22:53+08:00">2024-01-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://upaskun.github.io/2024/01/04/leetcode-easy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="upas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="upa4的窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/04/leetcode-easy/" class="post-title-link" itemprop="url">leetcode_easy</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-04 19:23:29" itemprop="dateCreated datePublished" datetime="2024-01-04T19:23:29+08:00">2024-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-08 20:18:34" itemprop="dateModified" datetime="2024-03-08T20:18:34+08:00">2024-03-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="array"><a href="#array" class="headerlink" title="array"></a>array</h2><h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3><ol>
<li>快慢指针法</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeElement</span><span class="params">(nums []<span class="type">int</span>, val <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">    slow := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> fast:=<span class="number">0</span>;fast&lt;<span class="built_in">len</span>(nums);fast++&#123;</span><br><span class="line">        <span class="keyword">if</span> nums[fast] == val&#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        nums[slow] == nums[fast]</span><br><span class="line">        slow++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>双指针法</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeElement</span><span class="params">(nums []<span class="type">int</span>, val <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">    left , right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> left&lt;=right&#123;</span><br><span class="line">        <span class="keyword">for</span> left &lt;= right &amp;&amp; nums[left]!=val&#123;</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> right &gt;= left &amp;&amp; nums[right] == val&#123;</span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> left &lt; right&#123;</span><br><span class="line">            nums[left] = nums[right]</span><br><span class="line">            left++</span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3个for循环都是有等于的，这是考虑到执行了if循环里的<code>left++</code>和<code>right--</code>之后，<code>left == right</code>的情况。<br>如果没有<code>=</code>,且此时<code>nums[left] != val</code>总个数就会漏算掉一个。所以for循环里的三个等于其实都是为了保证不遗漏边界情况。</p>
<h2 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h2><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [-4,-1,0,3,10]<br>输出：[0,1,9,16,100]<br>解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]<br>示例 2：</p>
<p>输入：nums &#x3D; [-7,-3,2,3,11]<br>输出：[4,9,9,49,121]</p>
<p>数组其实是有序的，只不过负数的平方可能成为最大数，所以可以尝试使用双指针，从两端点开始查找最大数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortedSquares</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    new_nums := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    l,r,i := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>,<span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i&gt;<span class="number">0</span>&#123;</span><br><span class="line">        lm := nums[l] * nums[l]</span><br><span class="line">        rm := nums[r] * nums[r]</span><br><span class="line">        <span class="keyword">if</span> lm&gt;rm&#123;</span><br><span class="line">            new_nums[i] = lm</span><br><span class="line">            l++</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            new_nums[i] = rm</span><br><span class="line">            r--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> new_nums</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用双指针法，时间复杂度为O(n)</p>
<h3 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h3><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p>
<p>示例：</p>
<p>输入：s &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]<br>输出：2<br>解释：子数组 [4,3] 是该条件下的长度最小的子数组。<br>提示：</p>
<p>1 &lt;&#x3D; target &lt;&#x3D; 10^9<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 10^5</p>
<p>仍然是双指针的一个问题。当不满足条件时，快指针向前移动；当满足条件时，慢指针向前移动</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minSubArrayLen</span><span class="params">(target <span class="type">int</span>, nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    numlen = <span class="built_in">len</span>(nums)</span><br><span class="line">    result := numlen + <span class="number">1</span></span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j:=<span class="number">0</span>;j &lt; numlen;j++&#123;</span><br><span class="line">        sum += nums[j]</span><br><span class="line">        <span class="keyword">for</span> sum &gt;= target&#123;</span><br><span class="line">            subLength := j-i+<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> subLength &lt; result&#123;</span><br><span class="line">                result = subLength</span><br><span class="line">            &#125;</span><br><span class="line">            sum -= num[i]</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> result &gt; numlen &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用场景： 从有序集合中查找满足某种条件的值</p>
<h3 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>适合查找在一个<strong>有序</strong>数组中查找、删除某个元素，时间复杂度O(n)</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h3><p>一开始的思路是用空间换时间，先创建一个数组，存储链表中的元素，再交换，时间复杂度为O(n)，空间复杂度也为O(n)，<br>一看别人的解法，直接交换指针的方向就行，真是米奇妙妙屋TAT</p>
<p>My solution（虽然菜，但万一我以后还写不出来呢？）</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="built_in">len</span> := <span class="number">0</span></span><br><span class="line">    linklist := []*ListNode&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> cur:=head;cur!=<span class="literal">nil</span>;cur=cur.Next&#123;</span><br><span class="line">        linklist = <span class="built_in">append</span>(linklist,cur)</span><br><span class="line">        <span class="built_in">len</span>++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>/<span class="number">2</span>;i++&#123;</span><br><span class="line">        tmp := linklist[i].Val</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>-i<span class="number">-1</span> &lt; <span class="number">0</span>&#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125; </span><br><span class="line">        linklist[i].Val = linklist[<span class="built_in">len</span>-i<span class="number">-1</span>].Val</span><br><span class="line">        linklist[<span class="built_in">len</span>-i<span class="number">-1</span>].Val = tmp </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更好的解法<br><img src="/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f676966732f3230362e2545372542462542422545382542442541432545392539332542452545382541312541382e676966.gif" alt="图解"></p>
<p>先记录当前链表节点，然后将当前链表往后移动，将记录链表的Next指向pre(pre是变向后的新链表的头节点)，将新链表的头节点设置为当前链表节点。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">var</span> pre *ListNode</span><br><span class="line">    <span class="keyword">for</span> cur:=head;cur!=<span class="literal">nil</span>;&#123;</span><br><span class="line">        tmp := cur</span><br><span class="line">        cur = cur.Next</span><br><span class="line">        tmp.Next = pre</span><br><span class="line">        pre = tmp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="024-两两交换链表中的节点"><a href="#024-两两交换链表中的节点" class="headerlink" title="024. 两两交换链表中的节点"></a>024. 两两交换链表中的节点</h3><p>My solution</p>
<p>思路： 对于中间的节点，如果下标为奇数， 就将该点与前一个点交换：将当前节点的下标与后一个点交换</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapPairs</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    i:=<span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> pre,cur *ListNode</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    pre = head</span><br><span class="line">    head = head.Next</span><br><span class="line">    <span class="keyword">for</span> cur=pre.Next;cur!=<span class="literal">nil</span> &amp;&amp; cur.Next!=<span class="literal">nil</span>;&#123;</span><br><span class="line">        cn := cur.Next</span><br><span class="line">        <span class="keyword">if</span> i%<span class="number">2</span>!=<span class="number">0</span>&#123;</span><br><span class="line">            pre.Next = cur.Next</span><br><span class="line">            cur.Next = pre</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre.Next = cur.Next</span><br><span class="line">            pre = cur</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cn</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> i%<span class="number">2</span> != <span class="number">0</span>&#123;</span><br><span class="line">        cur.Next = pre</span><br><span class="line">        pre.Next = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简便一些的方法，总体思路是一致的，但是加上头节点之后，就减少了头、尾的判断</p>
<p><img src="/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f706963732f32342e254534254238254134254534254238254134254534254241254134254536253844254132254539253933254245254538254131254138254534254238254144254537253941253834254538.png" alt="图解"></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapPairs</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    dummy := &amp;ListNode&#123;</span><br><span class="line">        Next: head,</span><br><span class="line">    &#125;</span><br><span class="line">    cur := dummy</span><br><span class="line">    <span class="keyword">for</span> cur.Next!=<span class="literal">nil</span> &amp;&amp; cur.Next.Next!=<span class="literal">nil</span>&#123;</span><br><span class="line">        tmp:=cur.Next</span><br><span class="line">        tmp1 := cur.Next.Next.Next</span><br><span class="line"></span><br><span class="line">        cur.Next = cur.Next.Next</span><br><span class="line">        cur.Next.Next = tmp</span><br><span class="line">        cur.Next.Next.Next = tmp1</span><br><span class="line">        cur = cur.Next.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="0019-删除链表的倒数第N个节点"><a href="#0019-删除链表的倒数第N个节点" class="headerlink" title="~*0019. 删除链表的倒数第N个节点"></a>~*0019. 删除链表的倒数第N个节点</h3><p>My solution：用空间换时间,记录所有节点</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeNthFromEnd</span><span class="params">(head *ListNode, n <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">    lenth := <span class="number">0</span></span><br><span class="line">    links := []*ListNode&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> cur:=head;cur!=<span class="literal">nil</span>;cur=cur.Next&#123;</span><br><span class="line">        links = <span class="built_in">append</span>(links,cur)</span><br><span class="line">        lenth++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n&gt;lenth &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n == lenth&#123;</span><br><span class="line">        <span class="keyword">return</span> head.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>&#123;</span><br><span class="line">        links[lenth-n<span class="number">-1</span>].Next = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    links[lenth-n<span class="number">-1</span>].Next = links[lenth-n].Next</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>QAQ又没想到，快慢指针法已经被我忘光了,得再复习一遍—</p>
<p>更好的解法：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeNthFromEnd</span><span class="params">(head *ListNode, n <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">    dummyHead := &amp;ListNode&#123;&#125;</span><br><span class="line">    dummyHead.Next = head</span><br><span class="line">    prev := dummyHead</span><br><span class="line">    i:=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> cur:=head;cur!=<span class="literal">nil</span>;cur=cur.Next&#123;</span><br><span class="line">        <span class="keyword">if</span> i&gt;n&#123;</span><br><span class="line">            prev = prev.Next</span><br><span class="line">        &#125;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    prev.Next = prev.Next.Next</span><br><span class="line">    <span class="keyword">return</span> dummyHead.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="160-链表相交"><a href="#160-链表相交" class="headerlink" title="160.链表相交"></a>160.链表相交</h3><p>题目描述</p>
<p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。<br>图示两个链表在节点 c1 开始相交</p>
<p><img src="/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303231313231393232313635372e706e67.png" alt="description"></p>
<p>现以尾端为基点对齐，然后再从头节点开始比较</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntersectionNode</span><span class="params">(headA, headB *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    lenA, lenB := <span class="number">0</span>,<span class="number">0</span> </span><br><span class="line">    curA, curB := headA, headB</span><br><span class="line">    <span class="keyword">for</span> curA!=<span class="literal">nil</span>&#123;</span><br><span class="line">        curA = curA.Next</span><br><span class="line">        lenA++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> curB!=<span class="literal">nil</span>&#123;</span><br><span class="line">        curB = curB.Next</span><br><span class="line">        lenB++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> fast, slow *ListNode</span><br><span class="line">    <span class="keyword">var</span> n <span class="type">int</span></span><br><span class="line">    <span class="keyword">if</span> lenA &gt; lenB&#123;</span><br><span class="line">        fast = headA</span><br><span class="line">        slow = headB</span><br><span class="line">        n = lenA - lenB</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        fast = headB</span><br><span class="line">        slow = headA</span><br><span class="line">        n = lenB - lenA</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;n;i++&#123;</span><br><span class="line">        fast = fast.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> fast!=slow&#123;</span><br><span class="line">        fast = fast.Next</span><br><span class="line">        slow = slow.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fast</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="142-环形链表"><a href="#142-环形链表" class="headerlink" title="~*142. 环形链表"></a>~*142. 环形链表</h3><p>题目描述:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</span><br><span class="line"></span><br><span class="line">如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</span><br><span class="line"></span><br><span class="line">不允许修改 链表。</span><br></pre></td></tr></table></figure>
<p><strong>没有思路</strong>。。。<br>看了讲解，仍然使用快慢指针的方式，快指针一次走两步，慢指针一次走一步，如果快指针追上慢指针，说明存在环, 如果不存在环，则一定存在为Next为nil的节点，此时返回nil</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">detectCycle</span><span class="params">(head *ListNode)</span></span> *ListNode&#123;</span><br><span class="line">    fast, slow = head, head</span><br><span class="line">    <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span>&#123;</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        <span class="keyword">if</span> fast == slow&#123;</span><br><span class="line">            <span class="keyword">for</span> slow != head&#123;</span><br><span class="line">                slow = slow.Next</span><br><span class="line">                head = head.Next</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> head </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="0242-有效的字母异位词"><a href="#0242-有效的字母异位词" class="headerlink" title="0242.有效的字母异位词"></a>0242.有效的字母异位词</h3><p>题目描述</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</span><br><span class="line"></span><br><span class="line">示例 1: 输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot; 输出: true</span><br><span class="line"></span><br><span class="line">示例 2: 输入: s = &quot;rat&quot;, t = &quot;car&quot; 输出: false</span><br><span class="line"></span><br><span class="line">说明: 你可以假设字符串只包含小写字母。</span><br></pre></td></tr></table></figure>

<p>My solution:<br>这道题还是比较简单的，但看了最快速的方法后，发现自己还是想得稍微又些复杂了T_T<br>我的想法是创建一个map，以a-z为键值初始化，遍历s，再遍历t，然后检查</p>
<p>总体的思路是一致的，区别在于其实可以直接使用数组，而不是map来做。</p>
<p>better way:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isAnagram</span><span class="params">(s <span class="type">string</span>, t <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> strlen(s)!=strlen(t) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    hashtable:=[<span class="number">26</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _,si := <span class="keyword">range</span> s&#123;</span><br><span class="line">        hashtable[si-<span class="type">rune</span>(<span class="string">&#x27;a&#x27;</span>)]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _,ti := <span class="keyword">range</span> t&#123;</span><br><span class="line">        hashtable[ti-<span class="type">rune</span>(<span class="string">&#x27;a&#x27;</span>)]--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hashtable == [<span class="number">26</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1002-查找常用字符"><a href="#1002-查找常用字符" class="headerlink" title="1002. 查找常用字符"></a>1002. 查找常用字符</h3><p>题目描述</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给你一个字符串数组 words ，请你找出所有在 words 的每个字符串中都出现的共用字符（ 包括重复字符），并以数组形式返回。你可以按 任意顺序 返回答案。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：words = [&quot;bella&quot;,&quot;label&quot;,&quot;roller&quot;]</span><br><span class="line">输出：[&quot;e&quot;,&quot;l&quot;,&quot;l&quot;]</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：words = [&quot;cool&quot;,&quot;lock&quot;,&quot;cook&quot;]</span><br><span class="line">输出：[&quot;c&quot;,&quot;o&quot;]</span><br></pre></td></tr></table></figure>

<p>TAT又没做出来，做的时候，感觉用1个hash表不太够，还得增加一个临时的，但最终没有下手</p>
<p>解法</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">commonChars</span><span class="params">(words []<span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    hashmap := [<span class="number">26</span>]<span class="type">int</span>&#123;<span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(words) == <span class="number">1</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="type">string</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, c:= <span class="keyword">range</span> words[<span class="number">0</span>]&#123;</span><br><span class="line">        hashmap[c-<span class="type">rune</span>(<span class="string">&#x27;a&#x27;</span>)]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="built_in">len</span>(words);i++&#123;</span><br><span class="line">        otherHashmap := [<span class="number">26</span>]<span class="type">int</span>&#123;<span class="number">0</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> _,c := <span class="keyword">range</span> words[i]&#123;</span><br><span class="line">            otherHashmap[c-<span class="type">rune</span>(<span class="string">&#x27;a&#x27;</span>)]++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> idx:=<span class="number">0</span>;idx&lt;<span class="number">26</span>;idx++&#123;</span><br><span class="line">            hashmap[idx] = min(otherHashmap[idx],hashmap[idx])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> idx:=<span class="number">0</span>;idx&lt;<span class="number">26</span>;idx++&#123;</span><br><span class="line">        <span class="keyword">for</span> cnt:=<span class="number">0</span>;cnt&lt;hashmap[idx];cnt++&#123;</span><br><span class="line">            ret = <span class="built_in">append</span>(ret,<span class="type">string</span>(<span class="string">&#x27;a&#x27;</span>+idx))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h3><p>题目描述</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">输出：[2]</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><br><span class="line">输出：[9,4]</span><br><span class="line">解释：[4,9] 也是可通过的</span><br></pre></td></tr></table></figure>
<p>没啥好说的，过了</p>
<h3 id="0202-快乐数"><a href="#0202-快乐数" class="headerlink" title="0202. 快乐数"></a>0202. 快乐数</h3><p>题目描述</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">编写一个算法来判断一个数 n 是不是快乐数。</span><br><span class="line"></span><br><span class="line">「快乐数」 定义为：</span><br><span class="line"></span><br><span class="line">对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</span><br><span class="line">然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。</span><br><span class="line">如果这个过程 结果为 1，那么这个数就是快乐数。</span><br><span class="line">如果 n 是 快乐数 就返回 true ；不是，则返回 false 。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：n = 19</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">12 + 92 = 82</span><br><span class="line">82 + 22 = 68</span><br><span class="line">62 + 82 = 100</span><br><span class="line">12 + 02 + 02 = 1</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：n = 2</span><br><span class="line">输出：false</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>离谱，怎么和哈希表扯上关系了😭，如果这题没开在hash表，真的想不到该这么做<br>思路： 根据条件，知道一共就两种情况A.无限循环，B. 结果为1。将每次的计算结果都存储到map中，当某个数第二次出现时，说明出现了循环的情况，返回false</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(num <span class="type">int</span>)</span></span><span class="type">int</span>&#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n&gt;<span class="number">0</span>&#123;</span><br><span class="line">        sum+=(n%<span class="number">10</span>) *(n%<span class="number">10</span>)</span><br><span class="line">        n = n/<span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isHappy</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    m:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> n!=<span class="number">1</span> &amp;&amp; !m[n]&#123;</span><br><span class="line">        n,m[n] = getSum(n),<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h3><p>（噩）梦开始的地方TAT</p>
<p>题目描述</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</span><br><span class="line"></span><br><span class="line">你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</span><br><span class="line"></span><br><span class="line">你可以按任意顺序返回答案。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure>
<p>居然一下就做出来了（可能是知道了这道题要用哈希表做）<br>hash的键是target-nums[i]，值是i<br>如果nums[j] 在hash表中存在，说明配对成功</p>
<h3 id="454-四数相加"><a href="#454-四数相加" class="headerlink" title="454. 四数相加"></a>454. 四数相加</h3><p>题目描述</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：</span><br><span class="line"></span><br><span class="line">0 &lt;= i, j, k, l &lt; n</span><br><span class="line">nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</span><br></pre></td></tr></table></figure>

<p>没有什么好思路…<br>使用比较暴力的解法, 计算第一组和第二组的集合中各种和的组合，并将其(*-1)后的值记录在hash表中，然后计算第三组和第四组中和的组合并判断当前值是否在哈希表中，如果在，就计算。<br>ok, 看了答案也是这个思路，暴力出奇迹啊～</p>
<p>写完看解析，还有与这道题相似的其他 </p>
<h3 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a>383. 赎金信</h3><p>题目描述</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。</span><br><span class="line"></span><br><span class="line">(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line">你可以假设两个字符串均只含有小写字母。</span><br><span class="line"></span><br><span class="line">canConstruct(&quot;a&quot;, &quot;b&quot;) -&gt; false</span><br><span class="line">canConstruct(&quot;aa&quot;, &quot;ab&quot;) -&gt; false</span><br><span class="line">canConstruct(&quot;aa&quot;, &quot;aab&quot;) -&gt; true</span><br></pre></td></tr></table></figure>
<p>没啥好说的。</p>
<h3 id="015-三数之和"><a href="#015-三数之和" class="headerlink" title="015. 三数之和"></a>015. 三数之和</h3><p>题目描述</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</span><br><span class="line"></span><br><span class="line">注意： 答案中不可以包含重复的三元组。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">给定数组 nums = [-1, 0, 1, 2, -1, -4]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]</span><br></pre></td></tr></table></figure>

<p>My solution: 击败百分之5.02%的用户TAT<br>思路是先创建哈希表，再两次遍历hash表，此处有一个限制，就是<code>a&lt;=b&lt;=c</code>，这么做其实是为了去重<br>(还是记录一下自己的方法，没准以后写不出来😓)</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">	result := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">	<span class="keyword">for</span> _, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		hash[n]++</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span> ki, vi := <span class="keyword">range</span> hash &#123;</span><br><span class="line">		<span class="keyword">for</span> kj, vj := <span class="keyword">range</span> hash &#123;</span><br><span class="line">            <span class="keyword">if</span> kj &lt; ki&#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            tmphash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">            tmphash[ki] = vi - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> kj == ki&#123;</span><br><span class="line">                vj = vi<span class="number">-2</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                vj--</span><br><span class="line">            &#125;</span><br><span class="line">            tmphash[kj] = vj</span><br><span class="line">			<span class="keyword">if</span> ki&gt; kj || tmphash[ki] &lt; <span class="number">0</span> || tmphash[kj] &lt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			kz := <span class="number">0</span> - ki - kj</span><br><span class="line">			<span class="keyword">if</span> vz, ok := hash[kz]; ok &amp;&amp; kz &gt;= kj &#123;</span><br><span class="line">				<span class="keyword">if</span> _, tok := tmphash[kz]; tok &#123;</span><br><span class="line">					tmphash[kz]--</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					tmphash[kz] = vz - <span class="number">1</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> tmphash[kz] &gt;= <span class="number">0</span> &amp;&amp; tmphash[kj] &gt;= <span class="number">0</span> &amp;&amp; tmphash[ki] &gt;= <span class="number">0</span> &#123;</span><br><span class="line">					result = <span class="built_in">append</span>(result,[]<span class="type">int</span>&#123;ki, kj, kz&#125;)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更好的思路：先排个序，然后遍历数组（最后两个值除外），对于每个数，设置快慢指针，慢指针初始值为当前值的后一个，如果3数和小于0，慢指针向右移，快指针指向数组结尾，如果和大了，就左移。(中间还穿插一些去重，总体来说，还是有些复杂的)</p>
<p><strong>双指针法</strong></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">	result := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	sort.Ints(nums)</span><br><span class="line">    <span class="keyword">if</span> nums[<span class="number">0</span>] &gt; <span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">3</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>] == <span class="number">0</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">append</span>(result,nums)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nlen := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;nlen<span class="number">-2</span>;i++&#123;</span><br><span class="line">        slow:=i+<span class="number">1</span></span><br><span class="line">        fast := nlen<span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> i&gt;<span class="number">0</span>&amp;&amp;nums[i] == nums[i<span class="number">-1</span>]&#123;</span><br><span class="line">            <span class="keyword">continue</span> <span class="comment">// 跳过下一个</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> slow &lt; fast&#123;</span><br><span class="line">            sums := nums[i] + nums[slow] + nums[fast]</span><br><span class="line">            <span class="keyword">if</span> sums &gt; <span class="number">0</span>&#123;</span><br><span class="line">                fast--</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> sums&lt;<span class="number">0</span>&#123;</span><br><span class="line">                slow++</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">                result = <span class="built_in">append</span>(result,[]<span class="type">int</span>&#123;nums[i],nums[slow],nums[fast]&#125;)</span><br><span class="line">                sn:= nums[slow]</span><br><span class="line">                <span class="keyword">for</span> slow&lt;fast &amp;&amp; nums[slow]== sn&#123;</span><br><span class="line">                    slow++</span><br><span class="line">                &#125; </span><br><span class="line">                fn:=nums[fast]</span><br><span class="line">                <span class="keyword">for</span> slow&lt;fast &amp;&amp; nums[fast] == fn&#123;</span><br><span class="line">                    fast--</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一些总结:<br>双指针法适用于在一个数组内查找满足条件的<strong>值</strong> </p>
</blockquote>
<h3 id="018-四数之和"><a href="#018-四数之和" class="headerlink" title="018. 四数之和"></a>018. 四数之和</h3><p>题目描述</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">题意：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line">答案中不可以包含重复的四元组。</span><br><span class="line"></span><br><span class="line">示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]</span><br></pre></td></tr></table></figure>
<p>思路：<br>在3sum的基础上再套个循环</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fourSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    ret := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums)&lt;<span class="number">4</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums)<span class="number">-3</span>;i++&#123;</span><br><span class="line">        <span class="keyword">if</span> i&gt;<span class="number">0</span>&amp;&amp;nums[i] == nums[i<span class="number">-1</span>]&#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> j:=i+<span class="number">1</span>;j&lt;<span class="built_in">len</span>(nums)<span class="number">-2</span>;j++&#123;</span><br><span class="line">            <span class="keyword">if</span> j &gt; i+<span class="number">1</span> &amp;&amp; nums[j] == nums[j<span class="number">-1</span>]&#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            fast := <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">            slow := j+<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> fast &gt;slow&#123;</span><br><span class="line">                sum_4 := nums[i] + nums[j] + nums[fast] + nums[slow]</span><br><span class="line">                <span class="keyword">if</span> sum_4 &gt; target&#123;</span><br><span class="line">                    fast--</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> sum_4 &lt; target&#123;</span><br><span class="line">                    slow++</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    slow_num := nums[slow]</span><br><span class="line">                    fast_num := nums[fast]</span><br><span class="line">                    ret = <span class="built_in">append</span>(ret, []<span class="type">int</span>&#123;nums[i],nums[j],slow_num,fast_num&#125;)</span><br><span class="line">                    <span class="keyword">for</span> slow &lt; fast &amp;&amp; nums[slow] == slow_num&#123;</span><br><span class="line">                        slow++</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> slow &lt; fast &amp;&amp; nums[fast] == fast_num&#123;</span><br><span class="line">                        fast--</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>难点确实是去重</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>KMP我来啦TAT</p>
<h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a>344. 反转字符串</h3><p>题目描述</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</span><br><span class="line"></span><br><span class="line">不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</span><br><span class="line"></span><br><span class="line">你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]</span><br><span class="line">输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span><br></pre></td></tr></table></figure>
<p>比较简单，过～</p>
<h3 id="541-反转字符串"><a href="#541-反转字符串" class="headerlink" title="541. 反转字符串"></a>541. 反转字符串</h3><p>题目描述</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。</span><br><span class="line"></span><br><span class="line">如果剩余字符少于 k 个，则将剩余字符全部反转。</span><br><span class="line"></span><br><span class="line">如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出: &quot;bacdfeg&quot;</span><br></pre></td></tr></table></figure>
<p>一开始还使出了快慢指针，后来发现多此一举</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(str []<span class="type">byte</span>, start, end <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	mid := (start + end) / <span class="number">2</span></span><br><span class="line">	<span class="keyword">for</span> start &lt;= mid &#123;</span><br><span class="line">		tmp := str[start]</span><br><span class="line">		str[start] = str[end]</span><br><span class="line">		str[end] = tmp</span><br><span class="line">		start++</span><br><span class="line">		end--</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseStr</span><span class="params">(s <span class="type">string</span>, k <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	sl := <span class="built_in">len</span>(s)</span><br><span class="line">	sb := []<span class="type">byte</span>(s)</span><br><span class="line">	start := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> ; sl-start &gt; <span class="number">2</span>*k; start += <span class="number">2</span> * k &#123;</span><br><span class="line">		reverse(sb, start, start+k<span class="number">-1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> sl-start &gt; k &#123;</span><br><span class="line">		reverse(sb, start, start+k<span class="number">-1</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		reverse(sb, start, sl<span class="number">-1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">string</span>(sb)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更简洁的写法</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseStr</span><span class="params">(s <span class="type">string</span>, k <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    ss := []<span class="type">byte</span>(s)</span><br><span class="line">    length := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i += <span class="number">2</span> * k &#123;</span><br><span class="line">     <span class="comment">// 1. 每隔 2k 个字符的前 k 个字符进行反转</span></span><br><span class="line">     <span class="comment">// 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符</span></span><br><span class="line">        <span class="keyword">if</span> i + k &lt;= length &#123;</span><br><span class="line">            reverse(ss[i:i+k])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reverse(ss[i:length])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(ss)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(b []<span class="type">byte</span>)</span></span> &#123;</span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    right := <span class="built_in">len</span>(b) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        b[left], b[right] = b[right], b[left]</span><br><span class="line">        left++</span><br><span class="line">        right--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151. 翻转字符串里的单词"></a>151. 翻转字符串里的单词</h3><p>题目描述</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串，逐个翻转字符串中的每个单词。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入: &quot;the sky is blue&quot;</span><br><span class="line">输出: &quot;blue is sky the&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: &quot;  hello world!  &quot;</span><br><span class="line">输出: &quot;world! hello&quot;</span><br><span class="line">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入: &quot;a good   example&quot;</span><br><span class="line">输出: &quot;example good a&quot;</span><br><span class="line">解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></pre></td></tr></table></figure>
<p>暂时想不到什么比较好的方法。很直接的思维。判断字符的界限嘛，把字符的起点和结尾的下标找到，拼接、倒序、放到另一个byte中，byte再转为string,难点是一些边界情况. &#x3D;_&#x3D; 写得又臭又长…</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseWords</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="comment">//1. Identify the blank string</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">1</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    &#125;</span><br><span class="line">    idx:=[][<span class="number">2</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    si,ei:=<span class="number">0</span>,<span class="number">-1</span></span><br><span class="line">    <span class="comment">//确定第一个单词起始位置</span></span><br><span class="line">    <span class="keyword">for</span> si=<span class="number">0</span>;si&lt;<span class="built_in">len</span>(s);si++&#123;</span><br><span class="line">        <span class="keyword">if</span> s[si] != <span class="string">&#x27; &#x27;</span>&#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i:=si;i&lt;<span class="built_in">len</span>(s)<span class="number">-1</span>;i++&#123;</span><br><span class="line">        <span class="keyword">if</span> s[i]!=<span class="string">&#x27; &#x27;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> s[i+<span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>&#123;</span><br><span class="line">                 ei = i</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> i+<span class="number">1</span> == <span class="built_in">len</span>(s)<span class="number">-1</span>&#123;</span><br><span class="line">                ei=i+<span class="number">1</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            idx = <span class="built_in">append</span>(idx,[<span class="number">2</span>]<span class="type">int</span>&#123;si,ei&#125;)</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> s[i+<span class="number">1</span>] != <span class="string">&#x27; &#x27;</span> &amp;&amp; i+<span class="number">1</span> ==<span class="built_in">len</span>(s)<span class="number">-1</span>&#123;</span><br><span class="line">                idx = <span class="built_in">append</span>(idx,[<span class="number">2</span>]<span class="type">int</span>&#123;i+<span class="number">1</span>,i+<span class="number">1</span>&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> i!=si &amp;&amp; s[i] == <span class="string">&#x27; &#x27;</span> &amp;&amp; s[i+<span class="number">1</span>]!=<span class="string">&#x27; &#x27;</span>&#123;</span><br><span class="line">            si=i+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret:=[]<span class="type">byte</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="built_in">len</span>(idx)<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--&#123;</span><br><span class="line">        tmp := []<span class="type">byte</span>(s[idx[i][<span class="number">0</span>]:idx[i][<span class="number">1</span>]+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> i!=<span class="number">0</span>&#123;</span><br><span class="line">            tmp = <span class="built_in">append</span>(tmp,<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        ret = <span class="built_in">append</span>(ret,tmp...)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>趁还没看解法之前再思考一下，看到对于字符可变类型的语言，能够做到空间复杂度为O(1), 估计这题的时间复杂度为O(n), 一个模糊的想法是，这题应该还是会用到至少两个指针吧？一个从开头出发，一个从结尾出发。？</p>
<p>总结：先去除多余的空格，再反转整个字符串，再反转每个单词</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseWords</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    b:=[]<span class="type">byte</span>(s)</span><br><span class="line">	slow, fast := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> ; fast &lt; <span class="built_in">len</span>(b); fast++ &#123;</span><br><span class="line">		<span class="keyword">if</span> b[fast] != <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> slow != <span class="number">0</span> &#123;</span><br><span class="line">				b[slow] = <span class="string">&#x27; &#x27;</span></span><br><span class="line">				slow++</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> fast &lt; <span class="built_in">len</span>(b) &amp;&amp; b[fast] != <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">				b[slow] = b[fast]</span><br><span class="line">				slow++</span><br><span class="line">				fast++</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	b = b[<span class="number">0</span>:slow]</span><br><span class="line">    reverse(b,<span class="number">0</span>,<span class="built_in">len</span>(b)<span class="number">-1</span>)</span><br><span class="line">    pi:=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="built_in">len</span>(b);i++&#123;</span><br><span class="line">        <span class="keyword">if</span> b[i<span class="number">-1</span>]!=<span class="string">&#x27; &#x27;</span>&amp;&amp;b[i]==<span class="string">&#x27; &#x27;</span>&#123;</span><br><span class="line">            reverse(b,pi,i<span class="number">-1</span>)</span><br><span class="line">            pi=i+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> pi&lt;<span class="built_in">len</span>(b)&#123;</span><br><span class="line">        reverse(b,pi,<span class="built_in">len</span>(b)<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(b []<span class="type">byte</span>,start,end <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> start&lt;end&#123;</span><br><span class="line">        b[start],b[end]=b[end],b[start]</span><br><span class="line">        start++</span><br><span class="line">        end--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="KMP"><a href="#KMP" class="headerlink" title="!!!KMP!!!"></a>!!!KMP!!!</h3><p>以前学的时候就感觉很难，多年之后的今天，是时候检验我的智商是否提高啦🤪</p>
<p>题目描述</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> 实现 strStr() 函数。</span><br><span class="line"></span><br><span class="line">给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</span><br><span class="line"></span><br><span class="line">示例 1: 输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot; 输出: 2</span><br><span class="line"></span><br><span class="line">示例 2: 输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot; 输出: -1</span><br><span class="line"></span><br><span class="line">说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</span><br></pre></td></tr></table></figure>
<p>2023.3.8: 算啦，还是把困难留给明天吧😴</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://upaskun.github.io/2024/01/03/k8s/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="upas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="upa4的窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/03/k8s/" class="post-title-link" itemprop="url">k8s</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-03 19:12:32 / 修改时间：20:26:17" itemprop="dateCreated datePublished" datetime="2024-01-03T19:12:32+08:00">2024-01-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>fxx曰：能记多少是多少</p>
</blockquote>
<h2 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h2><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>在k8s中，每个pod都有一个ip地址，对于一个网站来说，如果某个后端的pod寄了，前端咋能知道新上任的后端pod的ip呢？</p>
<p>在k8s中，可以将一个后端应用程序组暴露为一个Service。这样，无论后端应用程序的实际部署方式如何变化，外部客户端仍然可以通过Service访问后端应用程序，而无需关心其具体部署的细节。Service提供了反向代理的功能</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://upaskun.github.io/2023/12/30/cpp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="upas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="upa4的窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/30/cpp/" class="post-title-link" itemprop="url">cpp</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-12-30 00:04:11" itemprop="dateCreated datePublished" datetime="2023-12-30T00:04:11+08:00">2023-12-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-24 20:59:50" itemprop="dateModified" datetime="2024-01-24T20:59:50+08:00">2024-01-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="将一个函数作为另一个函数的参数"><a href="#将一个函数作为另一个函数的参数" class="headerlink" title="将一个函数作为另一个函数的参数"></a>将一个函数作为另一个函数的参数</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title function_">funcName</span><span class="params">(type (*funcNameAsParam)(type,type), type param2, ...)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*funcNameAsParam)(param1, param2)</span><br></pre></td></tr></table></figure>

<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>c++支持引用传递，通常被用到数组中</p>
<p>当数据较大的时候，使用引用比较好</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">100</span>,b=<span class="number">200</span>;</span><br><span class="line">    <span class="built_in">swap</span>(a,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>通过函数原型的方式可以给函数设置默认值，⚠️函数定义不能设置为默认值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> *<span class="title">left</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">int</span> n = <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="built_in">left</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="built_in">left</span>(<span class="string">&quot;world&quot;</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="title">left</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>函数特征标：参数数目以及类型&amp;&amp;参数的排列顺序</p>
<p>函数重载要求函数的特征标不同</p>
<p><em>类型引用和类型本身会被编译器视为同一特征标</em></p>
<p><strong>匹配参数时</strong>，并不区分const和非const</p>
<h4 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> AnyType&gt;</span><br><span class="line"><span class="comment">//template &lt;class AnyType&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(AnyType &amp;a, AnyType &amp;b)</span></span>&#123;</span><br><span class="line">    AnyType temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用上述的模板无法处理某些类型，比如结构，这时候可以为特定类型提供显化的模板，或者使用函数重载</p>
<p>编译器的选择顺序：</p>
<p>非模板函数&gt;具体显化&gt;模板函数</p>
<p>区别：实例化和具体化</p>
<p>显示实例化，由编译器根据模板创建</p>
<blockquote>
<p>template 函数返回类型 函数名&lt;模板类型&gt;(模板类型);</p>
</blockquote>
<p>显示具体化</p>
<blockquote>
<p>template &lt;&gt; 函数返回类型 函数名(&lt;模板类型&gt;)(模板类型);</p>
</blockquote>
<p>函数名后的模板类型可以省略。</p>
<p>使用显示具体化声明的意思是不要使用模板来生成定义，而应该使用自己的函数定义。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://upaskun.github.io/2023/12/28/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="upas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="upa4的窝">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/28/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-12-28 15:37:51" itemprop="dateCreated datePublished" datetime="2023-12-28T15:37:51+08:00">2023-12-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">upas</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">upas</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
